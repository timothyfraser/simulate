#' calculate() Function
#'
#' This function calculates simulated outcomes based on an N-row data.frame of K-columns of coefficients, supplied from equate().
#' @param equations (Required) Data.frame containing multivariate normal distribution of coefficient terms, generated by equate().
#' @param setx (Optional) List containing specific hypothetical predictor values of X for key coefficients. All others held at medians/modes.
#' @param newdata (Optional) Data.frame containing hypothetical predictor values of X for K-columns of coefficients. 
#' @param options (NULL by default) List of options `keep = FALSE`, `phi = TRUE`, and `var = FALSE` 
#'
#' @param keep Logical which if TRUE tells model to keep the contents of newdata in output data.frame. If FALSE, exclude them for efficiency. 
#' @param phi Logical which if TRUE tells model to use simulated phi (only applicable for `betareg` models).
#' @param var Logical which if TRUE tells model to calculate variance (only applicable for `betareg` models).
#' @keywords simulation
#' @export
#' @examples
#' 
#' # Load Packages
#' library(simulate)
#' library(tidyverse)
#' 
#' # Make a regression model
#' mymodel <- mtcars %>% lm(formula = mpg ~ disp + factor(cyl))
#' 
#' # Generate 1000 simulations, accounting for estimation uncertainty
#' mymodel %>%
#'   equations() %>%
#'   calculate(newdata = mtcars)
#' 
#' # or...
#' 
#' mymodel %>%
#'   equate() %>%
#'   calculate(setx = list(disp = c(100, 200, 300)))

calculate = function(equations = NULL, setx = NULL, newdata = NULL, options = NULL){
  require(purrr)
  require(dplyr)
  require(tibble)
  require(stats)
  
  # By default, these are the options
  ops = list(keep = FALSE, phi = TRUE, var = FALSE)
  # If options are provided, overwrite our default values
  if(!is.null(options$keep)){ ops$keep <- options$keep }
  if(!is.null(options$phi)){ ops$phi <- options$phi }
  if(!is.null(options$var)){ ops$var <- options$var }
  
  
  # Add a warning
  if(is.null(equations)){
    print(paste("Requires equations from multivariate normal distribution. See equate()."))
    stop()}
  
  # If newdata is supplied
  if(!is.null(newdata)){
    print(paste("Using newdata. setx values will be ignored."))
    #newdata <- newdata
  }else{
    # If newdata is NOT supplied but setx is,
    if(!is.null(setx)){
      newdata <- attr(equations, "model") %>% get_newdata(m = ., setx = setx)
      print(paste("Predictor values set using contents of setx; otherwise, set to medians and modes by default."))
    }else{
      # If newdata is NOT supplied and setx is NOT supplied,
      print(paste("Predictor values set to medians and modes by default. Use setx to specify values."))
      newdata <- attr(equations, "model") %>% get_newdata(m = .)
    }
  }
  
  # For however many reps specified earlier in equate(),
  mycalculations <- 1:nrow(equations) %>%
    # Run the get_sim function, to calculate the prediction based on simulated model equations,
    # See ?get_sim() for more information.
    map_dfr(~get_sim(i = ., equations = equations, 
                     # Given the following new data
                     newdata = newdata, options = ops), .id = "replicate")
  
  
  # Store the model as an attribute
  structure(.Data = mycalculations,
            seed = attr(equations, "seed"),
            type = attr(equations, "type"),
            step = "calculate") %>%
    return()
}

