#' calculate() Function
#'
#' This function calculates simulated outcomes based on an N-row data.frame of K-columns of coefficients, supplied from equations().
#' @param equations (Required) Data.frame containing multivariate normal distribution of coefficient terms, generated by equations().
#' @param setx (Optional) List containing specific hypothetical predictor values of X for key coefficients. All others held at medians/modes.
#' @param newdata (Optional) Data.frame containing hypothetical predictor values of X for K-columns of coefficients. 
#' @param keep (FALSE by default) Logical which if TRUE tells model to keep the contents of newdata in output data.frame. If FALSE, exclude them for efficiency. 
#' @keywords simulation
#' @export
#' @examples
#' 
#' # Load Packages
#' library(simulate)
#' library(tidyverse)
#' 
#' # Make a regression model
#' mymodel <- mtcars %>% lm(formula = mpg ~ disp + factor(cyl))
#' 
#' # Generate 1000 simulations, accounting for estimation uncertainty
#' mymodel %>%
#'   equations() %>%
#'   calculate(newdata = mtcars)
#' 
#' # or...
#' 
#' mymodel %>%
#'   equations() %>%
#'   calculate(setx = list(disp = c(100, 200, 300)))

calculate = function(equations = NULL, setx = NULL, newdata = NULL, keep = FALSE){
  require(purrr)
  require(dplyr)
  require(tibble)
  require(stats)
  
  # Add a warning
  if(is.null(equations)){
    print(paste("Requires equations from multivariate normal distribution. See equations()."))
    stop()}
  
  # If newdata is supplied
  if(!is.null(newdata)){
    print(paste("Using newdata. setx values will be ignored."))
    #newdata <- newdata
  }else{
    # If newdata is NOT supplied but setx is,
    if(!is.null(setx)){
      newdata <- attr(equations, "model") %>% get_newdata(m = ., setx = setx)
      print(paste("Predictor values set using contents of setx; otherwise, set to medians and modes by default."))
    }else{
      # If newdata is NOT supplied and setx is NOT supplied,
      print(paste("Predictor values set to medians and modes by default. Use setx to specify values."))
      newdata <- attr(equations, "model") %>% get_newdata(m = .)
    }
  }
  
  # For however many reps specified earlier in equations(),
  mycalculations <- 1:nrow(equations) %>%
    # Run the get_sim function, to calculate the prediction based on simulated model equations,
    # See ?get_sim() for more information.
    map_dfr(~get_sim(i = ., equations = equations, 
                     # Given the following new data
                     newdata = newdata, keep = keep), .id = "replicate")
  
  
  # Store the model as an attribute
  structure(.Data = mycalculations,
            seed = attr(equations, "seed"),
            type = attr(equations, "type"),
            step = "calculate") %>%
    return()
}

