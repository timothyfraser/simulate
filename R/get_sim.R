#' get_sim() Function
#'
#' This function calculates simulated outcomes based on an N-row data.frame of K-columns of coefficients, supplied from equations(). Internal function; use get_predictions() instead.
#' @param i (Require) single number representing the row-number of the multivariate normal distribution simulated in equations().
#' @param equations (Required) Data.frame containing multivariate normal distribution of coefficient terms, generated by equations().
#' @param newdata (Required) Data.frame containing hypothetical predictor values of X for K-columns of coefficients. 
#' @param options (Optional) Options passed from [calculate()]. See [calculate()] for details.
#' @keywords simulation
#' @export


get_sim = function(i, equations, newdata = newdata, options = NULL){
  # Extract model from attributes of your simulated model equations
  m <- attr(equations, "model")
  type <- attr(equations, "type")
  
  #############################
  # Get Simulated Coefficients
  #############################
  
  # Update model coefficients with vector of new simulated coefficients. 
  # Starts at column 2 to avoid id column 'replicate'
  
  # If most models, extract like so
  if(type %in% c("lm", "glm", "negbin", "logit", "poisson")){
    m$coefficients <- equations[i,2:ncol(equations)] %>% unlist()
  }
  
  # If beta regression, extract this way
  if(type %in% c("betareg")){
    # Get all but last column (phi)
    m$coefficients$mean <- equations[i,2:(ncol(equations)-1)] %>% unlist()
    
    # If you added the optional argument phi, check if phi is FALSE
      if(options$phi == FALSE){
        # If so, don't vary phi; hold it constant
      }else{
        # Otherwise, get phi, the last column
        m$coefficients$precision <- equations[i,ncol(equations)] %>% unlist()
      }
    }
  
  #####################
  # Gather Error Terms
  #####################
  
  # In OLS model, use sigma, the residual standard error
  # eg.: rnorm(n = 1000, mean = yhat, sd = error)
  if(type == "lm"){
  output <- tibble(
    # Predict outcome using supplied x values in data.frame newdata
    ysim = predict(m, newdata = newdata, type = "response"),
    # Get the error term
    sigma = broom::glance(m)$sigma)
  }

  # In logit, use nothing
  # rbinom(n = 1000, size = 1, prob = yhat)
  if(type == "logit"){
    output <- tibble(
      # Predict outcome using supplied x values in data.frame newdata
      ysim = predict(m, newdata = newdata, type = "response"))
  }

  # In poisson, use nothing; Poisson assumes a dispersion of 1
  # eg. rpois(n = 1000, lamda = yhat)
  if(type == "poisson"){
    output <- tibble(
      # Predict outcome using supplied x values in data.frame newdata
      ysim = predict(m, newdata = newdata, type = "response"))
  }
  
  # If gamma, use dispersion parameter
  # eg. rgamma(n = 1000, shape = yhat, scale = 1 / error)
  if(type == "gamma"){
    output <- tibble(
      # Predict outcome using supplied x values in data.frame newdata
      ysim = predict(m, newdata = newdata, type = "response"),
      # Get dispersion parameter; 1/dispersion = scale in rgamma 
      disperson = summary(m)$dispersion)
    # eg. rgamma(n = 1000, shape = yhat, scale = 1 / error)
  }
  
  # In negative binomial, use theta, the dispersion parameter
  # eg. rnegbin(n = 1000, mu = yhat, theta = error)
  if(type == "negbin"){
    tibble(
      # Predict outcome using supplied x values in data.frame newdata
      ysim = predict(m, newdata = newdata, type = "response"),
      # Get dispersion parameter theta.
      theta = m$theta)
  }

  # In Beta regression, use phi, the precision parameter
  # eg. rbeta(n = 1000, shape1 = , shape2 = mu * error, shape2 = (1 - mu)*error)
  if(type == "betareg"){
    output <- tibble(
      # Predict outcome using supplied x values in data.frame newdata
      ysim = predict(m, newdata = newdata, type = "response"),
      # Grab the precision term too, since it was simulated
      phi = predict(m, newdata = newdata, type = "precision"))
    if(options$var == TRUE){
      # If variance == TRUE, also add this column
      output %>%
        mutate(var = predict(m, newdata = newdata, type = "variance"))
    }
    
  }
  
  
  # we'll also assign a case ID to each row in new data, 
  # so simulations can be retroactively joined back with variables from newdata.
  output <- output %>%
    mutate(case = 1:n())
  
  
  # Finally, if keep = TRUE, add in the newdata;
  if(options$keep == TRUE){
    output %>% mutate(newdata) %>% return()
  }else{
    # otherwise, just return the simulation. This is faster.
    output %>% return()
  }
}
