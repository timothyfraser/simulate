#' get_coeftable() Function
#'
#' This underlying function derives a summary table based on basic alpha & coefficient standard errors, test statistics, and p-values from a multivariate normal distribution, circumventing constraints on ordinary standard errors.
#' @param data (Optional) Data.frame containing multivariate normal distribution of coefficient terms, generated by equations(). 
#' @param ci (Optional) Single value from 0 to 1. Defaults to 0.95, for a 95% confidence interval.
#' @keywords coefficients table summary
#' @format
#' \describe{
#'   \item{term}{name of variable for which estimation uncertainty was measured}
#'   \item{estimate}{observed coefficient}
#'   \item{lower}{lower confidence interval for simulated coefficients, based on input ci. When ci = 0.95, defaults to 2.5th percentile.}
#'   \item{upper}{upper confidence interval for simulated coefficients, based on input ci. When ci = 0.95, defaults to 97.5th percentile.}
#'   \item{se}{standard error, representing standard deviation of simulated coefficients.}
#'   \item{p_value}{p-value calculated from simulations. Depicts false positive rate as the percentage of simulations on opposite side of 0 from the observed coefficient.}
#'   \item{stars}{Stars show statistical significance (*** p < 0.001, ** p < 0.01, * p < 0.05, . p < 0.10.)}
#' }
#
#' @export
#' @examples
#' 
#' # Load Packages
#' library(simulate)
#' library(tidyverse)
#' 
#' # Make a regression model
#' mymodel <- mtcars %>% lm(formula = mpg ~ disp + factor(cyl))
#' 
#' # Generate simulated coefficient table
#' mymodel %>%
#'   equations() %>%
#'   get_coeftable()
#'   
#' # More recommended is to use the summary() function, 
#' # which provides the right output for each layer in the simulation process.
#' mymodel %>%
#'   equations() %>%
#'   summary()
#'   

get_coeftable = function(data, ci = 0.95){
  require(dplyr)
  require(tibble)
  require(gtools)
  
  if(is.null(data)){
    print("Please provide a multivariate normal distribution of equations, outputted by equations().")
    stop()
  }
  
  # Get the observed coefficient names, values, and order in a data.frame
  obs <- tibble(term = names(attr(data, "coefficients")),  estimate = attr(data, "coefficients")) %>%
    mutate(order = 1:n())
  
  data %>%
    # Get a tidy data.frame of replicates, terms, and simulated coefficients
    pivot_longer(cols = -c(replicate), names_to = "term", values_to = "simcoef") %>% 
    # Join in the observed values
    left_join(by = "term", y = obs) %>%
    # For each term, in that order,
    group_by(order, term) %>%
    # Calculate the following statistics:
    summarize(
      # Retain original terms and estimates
      term = unique(term),
      estimate = unique(estimate),
      # Get confidence intervals directly from distribution
      lower_ci = quantile(simcoef, probs = (1 - ci) / 2),
      upper_ci = quantile(simcoef, probs = ci + (1 - ci) / 2),
      # Get standard error directly from multivariate normal distribution
      se = sd(simcoef),
      # Get two-tailed p-value based directly on simulations
      p_value = 2*(1 - if_else(condition = estimate > 0,
                               true = sum(simcoef > 0),
                               false = sum(simcoef < 0) ) / n() ),
      # Add stars for p-values
      stars = gtools::stars.pval(p_value)
      
      # You could also condition it on sample size and number of model terms, but that's sort of redundant,
      # since the multivariate normal distribution is already showing estimation error.
      
      # If you wanted to, it would look like this.
      # calculate statistic from estimate and se
      # statistic = estimate / se,
      # p_value = 2*pt(q = -abs(statistic), df = attr(data, "nrows") - attr(data, "nvars"), lower.tail = TRUE),
      # get significance as asterisks
      ) %>%
    ungroup() %>%
    select(-order) %>%
    return()
}
